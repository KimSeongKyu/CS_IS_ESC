# 1. Paging
* 메모리 할당 기법에서 **비연속할당**
* **가상기억장치를 크기가 동일한 페이지로 나눠 처리하는 방법**
* 즉, **프로세스를 크기가 동일한 페이지로 나누고**, 메인 메모리도 프레임(페이지 프레임)이라는 **고정 크기 블록으로 나눠** 이 프레임에 **페이지를 적재**하는 방법
<p align = "center"><img src="https://user-images.githubusercontent.com/50662573/111065789-e0064900-84fe-11eb-8042-970aad5ff9cf.png" width="60%" height="60%"></img></p>   

* 연속 메모리 할당 시스템은 MMU를 이용하여 프로세스를 연속된 메인 메모리에 저장
* 페이징 시스템은 **프로세스를 페이지 4개로 나누어** **메인 메모리의 임의의 공간에 각각 저장**
* 페이징 시스템에서는 프로세스의 영역인 **페이지를 메인 메모리 영역인 프레임에 할당**한다.
  * 프로세스에 **필요한 페이지를 결정**하여 **페이지 번호를 부여**
  * 메모리의 빈 프레임을 조사하여 **프로세스를 적재할 위치 파악**
  * 프로세스의 페이지를 **빈 프레임에 적재**하도록 **준비**  
* 페이징 방법에서는 **빈 프레임**에 **어떤 페이지**든 **적재**할 수 있어 **메모리를 효율적**으로 사용할 수 있다.
* 프레임 간에 외부 단편화도 발생하지 않는다.
* 하지만 한 프로세스의 페이지를 메인 메모리의 여러 위치에 분산 적재하여 운영체제의 페이지 관리 부담이 크다.
* 프레임 단위로 적재하므로 **어떤 프로세스에 필요한 공간이 페이지 크기와 맞지 않으면**, 마지막 페이지에 할당된 프레임이 완전히 차지 않아
**내부 단편화**가 발생할 수 있다.   

  ex) 빈 공간이 500MB일 때 300MB 메모리를 사용하는 프로그램을 실행하면 200MB의 낭비가 생김

< 용어 >
* **페이지** : 가상메모리를 일정한 크기로 나눈 블록. 4K씩 나눌 수도 있고, 5K씩 나눌 수도 있다.
* **프레임** : 주기억장치를 일정한 크기로 나눈 블록.
* **Page-In(Swap-In)** : 가상메모리에 있는 페이지를 주기억장치에 올리는 것
* **Page-Out(Swap-Out)** : 주기억장치에 있던 것을 가상메모리로 되돌리는 것
* **Swapping** : Page-In, Page-Out과 같은 과정을 **페이지 교체 알고리즘**에 따라 수행되는 것
* **페이지 사상테이블(매핑)** : 프로세스의 페이지 정보를 저장하고 있는 테이블이다. 하나의 프로세스는 하나의 페이지 테이블을 가진다. 
페이지 번호, 페이지가 주기억장치에 적재되었는지 여부, 주기억장치 상에서의 시작주소가 저장된다.
* **Page Fault** : cpu가 프로그램을 실행하던 와중에 필요한 페이지가 주기억장치에 없는 상황
* **Demand Paging** : Page Fault를 해결하는 과정
* **스래싱** : Page Fault로 인한 성능다운을 의미   

[ 페이지 교체 알고리즘 ]
* **FIFO (First in first out)** : 메모리에 올라온지 가장 오래된 페이지를 교체
* **Optimal** : 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체
* **LRU (least-recently-used)** : 가장 오래 사용되지 않은 페이지를 교체
* **Counting-Based** : 페이지 참조 시마다 각 페이지가 현재까지 참조된 횟수를 카운팅하는 방법. 이를 이용해 2가지의 알고리즘을 만들 수 있다.
-> LFU와 MFU는 실제 사용에 잘 쓰이지 않음
  * **LFU(least-frequently-used)** : 참조 횟수가 가장 작은 페이지를 교체. 만약 교체 대상이 여러개일 경우, LRU에 따른다.
  * **MFU(most-frequently-used)** : 참조 횟수가 가장 많은 페이지를 교체. 횟수가 적은 페이지가 최근에 사용된 것이기 때문에 앞으로 사용될 가능성이 높다는 판단.

[ 페이징 기법 ]   

**1. 페이징 기법의 구현**
* **프로세스 고정 분할 방식**
  * **물리 주소 공간**을 **같은 크기**로 나누어 사용
  * **가상 주소 영역 각각의 분할 영역**을 **페이지**라고 함
  * **물리 주소 영역 각각의 분할 영역**을 **프레임**라고 함
  * 페이지와 프레임의 크기는 같으며 **1대1 매칭**
  
* **페이지 테이블**
  * **페이지-프레임 연결(매핑) 정보**를 담고 있는 자료구조
  * 색인(**페이지 번호**)와 내용(**매핑된 프레임의 시작 주소**)
  * 프로세스마다 페이지 테이블 1개 존재
  * 접근이 빨라야 하므로 메모리의 운영체제 영역에 존재

**2. 페이징 기법의 주소 변환**
* **페이지 크기**에 따라 **페이지가 주소의 수**가 **다르다**
  * ex) 메모리 워드가 1Byte인 컴퓨터에서 페이지와 프레임 크기가 128Byte이면 128개의 주소를 갖는다.
* 가상주소 VA = 를 물리주소 FA = 로 변환
  * P는 페이지 번호, D는 오프셋(페이지의 시작 처음 위치에서 해당 위치까지의 거리), F는 프레임 번호
  * ex) 페이지 크기 = 1024byte일 경우 CPU가 가상주소 2000번지를 발생시키면 VA = <1,976> FA =
  * 페이지 테이블 miss인 경우 스왑 영역에 존재
  
**3. 페이지 테이블 매핑 방식**
* **직접 매핑, 연관 매핑, 세트-연관 매핑, 역매핑**
  * **직접 매핑**
    * 페이지 테이블 전체가 메모리에 존재
    * **페이지 번호만 알면** **프레임 번호**를 **즉시 획득**할 수 있어 **속도가 빠르다**
    * 물리 메모리가 충분할 때 사용
    
  * **연관 매핑**
    * **직접 매핑 페이지 테이블 전체**를 **스왑 영역**에 두고 **일부**만 **메모리에 무작위로 올려 사용**
    * 메모리에 올라온 일부 테이블을 **변환 색인 버퍼(TLB)**라 부른다.
    * **TLB**는 **직접 매핑 페이지와 다르게 페이지 번호, 프레임 번호 2개의 열을 갖고 있다.**
    * TLB 히트(hit)인 경우 **곧바로 물리 주소로 변환**하고 **TLB miss**인 경우 **스왑 영역을 탐색**
    * **TLB를 모두 탐색한 후**에야 **TLB miss임을 알 수 있어** TLB miss가 **자주나면** **탐색 속도가 느려진다.**
    
  * 세트-연관 매핑(디렉터리 매핑)
    * 연관 매핑 방식을 개선한 방식
    * **페이지 테이블**을 **여러 집합**으로 **자르고**, **자른 덩어리 단위**로 **물리 메모리**에 가져온다.
    * **집합 테이블(디렉터리 테이블)**을 추가로 관리
    * 집합 테이블을 통해 **페이지 테이블 엔트리**가 **물리 메모리**, **스왑영역** 중 어디에 있는지 확인 후 탐색
    * 직접 메모리의 **물리 메모리 낭비**와 **연관 매핑의 탐색 속도 문제**를 **완화**
    
  * 역매핑
    * **프레임 번호**를 기준으로 **페이지 테이블을 구성**
    * **프레임 번호**를 **인덱스**로 하고 **프로세스 ID(PID)**와 **페이지 번호 열**을 가진다.
    * **전체 프로세스**를 통틀어 **하나의 페이지 테이블**만 가지므로 **크기가 아주 작다**.
    * **페이지 테이블의 행 수**가 **실제 프레임 수**와 **같다**.
    * **특정 프로세스의 페이지 번호**를 **찾으려면** **모든 테이블을 검색**해야 하므로 **매우 느리다.**
    * 페이지에서 **번호를 찾지 못하면** **스왑 영역**에서 **직접 매핑 테이블**을 **사용**해 **프레임 번호를 획득**한다.

# 2. Segmentation
* 가상기억장치를 **가변적인 크기의 블록으로 편성하여 운용**하는 기법. 가상기억장치의 블록의 크기가 제각각이므로 대신 주기억장치의 영역 구분을 없앤다.
그리고 **각 블록에 Protection Key라는 이름표**를 달아 준다.   

* **프레임이 없기 때문에** 내부단편화가 발생하지 않으나 **외부단편화가 발생**된다. 그래서 **주기적으로 압축이 필요**하다.
* 세그먼테이션 기법을 사용하는 가장 큰 이유는 **메모리를 효율적으로 관리**하기 위해서이다.
  ex) 실제로 필요한 기능이 300MB일 때 페이지 크기 단위가 400MB라면 필요 없는 100MB부분도 주기억장치에 올려야 하고, 이 때문에 시간, 공간적으로 비효율적이기 때문이다.
* 페이징 기법에 비해 물리적 개념보다는 **논리적**이란 장점이 있다.
* 논리적 내용의 단위로 자르기 때문에 세크먼트들의 크기는 일반적으로 같지 않다.
* 세그먼트의 길이가 모두 달라서, 세그먼트 길이에 맞는 주기억장치의 영역을 할당하지 못하면 다른 프로그램 영역을 침범하게 되는 세그먼트 오버플로우 결함이 발생한다.   

[ 세그멘테이션 기법 ]   

**1. 세그멘테이션 기법의 구현**
* **세그맨테이션 테이블 사용**
  * **세그먼트의 크기**를 나타내는 **limit**과 **물리 메모리상 주소**의 **시작주소 address 2개의 열**을 가진다.
  * **물리 메모리**가 **부족**하면 **스왑 영역 사용**
  * **메모리를 프로세스 단위로 관리**하므로 **페이지 테이블**이 **작고 단순**
  * **외부 단편화**로 인해 **물리 메모리 관리가 복잡**
  
**2. 세그멘테이션 기법의 주소 변환**
* **가상주소 VA = 를 물리주소로 변환**
  * **S**는 **세그먼트 번호**, **D**는 **오프셋**(세그먼트 시작 주소에서 해당 위치까지의 거리)
  * ex) CPU가 가상주소 VA = <3,5> (세그먼트 3의 5번지)를 발생시키면 메모리의 물리 주소 STBL(3) + 5번지로 이동
  * 계산된 물리 주소가 세그먼트에 할당된 영역을 벗어나면 트랩(주소 오류)를 발생시키고 프로세스를 강제 종료한다.   
  
[ 세그멘테이션-페이징 혼용 기법 ]
* 페이징 기법과 세그멘테이션 기법의 장점만을 취한 가상 메모리 관리 기법

**1. 메모리 접근 권한**
  * 읽기, 쓰기, 실행 권한의 조합
    * 코드 영역 : 읽기, 실행 가능
    * 데이터 영역 : 읽기는 항상 가능하며 변수, 상수에 따라 쓰기 권한 부여 결정
    
  * 가상 주소가 물리 주소로 변환될 때마다 메모리 접근 권한을 검사
    * 권한을 벗어난 시도는 트랩 발생
    * 매핑 테이블은 메모리 접근 권한 정보를 가지고 있어 주소 변환시에 유효한 접근인지 검사한다.
    
 **2. 페이징-세그멘테이션 혼용 기법의 도입**
  * 페이지 테이블에서 페이지마다 권한 비트를 추가하면 테이블 크기가 커져 메모리 낭비 발생
    * 인접한 페이지의 메모리 접근 권한은 같은 경우가 많다.
    * 페이지로 분할된 가상 주소 공간에서 관련 있는 영역을 하나의 세그먼트로 묶어 세그멘테이션 테이블로 관리
    * 세그멘테이션 테이블은 세그먼트별 페이지의 시작 주소를 갖는다.
    * 대부분의 OS가 이 방식을 사용
    
 **3. 페이징-세그멘테이션 혼용 기법의 주소 변환**
  * CPU가 발생시킨 **가상주소 VA =** 를 **물리주소**로 **변환**   
  
  (1) CPU가 가상주소 VA = 발생   
  
  (2) **세그먼테이션 테이블**에서 **권한을 검사**하고 **통과**하면 **페이지 테이블 시작 주소를 획득**   
  
  (3) **페이지 테이블**로 찾아가 **해당 페이지의 프레임 번호를 획득**  
  
  (4) **물리 메모리**에서 **해당 프레임**의 **처음 위치**에서 **D만큼 떨어진 데이터 획득**
